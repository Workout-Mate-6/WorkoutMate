# 워크플로우의 전체 이름을 "CI/CD Docker to EC2"로 정했음.
name: CI/CD Docker to EC2

# 언제 이 워크플로우를 실행할지 정하는 부분임.
on:
  push:
    # "hotfix/deployment" 브랜치에 코드가 push 될 때마다 실행될 거임.
    branches: [ "hotfix/deployment" ]

# 워크플로우가 해야 할 작업(job)들을 정의함.
jobs:
  # "build-and-deploy"라는 이름의 작업을 하나 만들었음.
  build-and-deploy:
    # 이 작업은 GitHub이 제공하는 최신 우분투 가상머신에서 돌아감.
    runs-on: ubuntu-latest

    # 이 작업이 수행할 단계(step)들을 순서대로 나열함.
    steps:
      # 1단계: 코드 내려받기
      - name: Checkout
        # GitHub 저장소에 있는 코드를 가상머신으로 복사해오는 액션을 사용함.
        uses: actions/checkout@v3

      # 2단계: 자바(JDK) 설치
      - name: Set up JDK 17
        # 가상머신에 특정 버전의 자바를 설치하는 액션을 사용함.
        uses: actions/setup-java@v3
        with:
          # 자바 버전을 '17'로 지정함.
          java-version: '17'
          # 'temurin'이라는 배포판을 사용함.
          distribution: 'temurin'
      
      # 3단계: gradlew 파일에 실행 권한 주기
      - name: Grant execute permission for gradlew
        # gradlew 파일이 실행될 수 있도록 권한을 변경함. 리눅스 환경이라 필수임.
        run: chmod +x gradlew
        
      # 4단계: 프로젝트 빌드
      - name: Build with Gradle
        # gradlew 명령어로 스프링 부트 프로젝트를 빌드함. 이걸 해야 .jar 파일이 생김.
        run: ./gradlew build -x test

      # 5단계: 도커 빌드 환경 설정
      - name: Set up Docker Buildx
        # 도커 이미지를 효율적으로 빌드하기 위한 Buildx라는 툴을 설정함.
        uses: docker/setup-buildx-action@v2

      # 6단계: 도커 허브 로그인
      - name: Login to Docker Hub
        # 도커 이미지를 올릴 Docker Hub에 로그인하는 액션을 사용함.
        uses: docker/login-action@v2
        with:
          # 아이디는 GitHub Secrets에 저장된 DOCKERHUB_USERNAME 값을 사용함.
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          # 비밀번호는 GitHub Secrets에 저장된 DOCKERHUB_TOKEN 값을 사용함.
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      # 7단계: 도커 이미지 빌드 및 푸시
      - name: Build and push
        # Dockerfile을 이용해 이미지를 만들고 Docker Hub에 올리는 액션을 사용함.
        uses: docker/build-push-action@v4
        with:
          # 현재 폴더(.)에 있는 Dockerfile을 사용해서 빌드함.
          context: .
          # 빌드 성공하면 바로 Docker Hub로 푸시(업로드)함.
          push: true
          # 이미지 이름은 "아이디/my-spring-app:latest" 형식으로 지정함.
          tags: ${{ secrets.DOCKERHUB_USERNAME }}/my-spring-app:latest

      # 8 단계: .env 파일을 생성해서 환경변수 준비
      - name: Create .env file from secret
        run: |
          echo "DEPLOY_DB_URL=${{ secrets.DEPLOY_DB_URL }}" > .env
          echo "DEPLOY_DB_USERNAME=${{ secrets.DEPLOY_DB_USERNAME }}" > .env
          echo "DEPLOY_DB_PASSWORD=${{ secrets.DEPLOY_DB_PASSWORD }}" > .env
          echo "SECRET_KEY=${{ secrets.SECRET_KEY }}" > .env
          echo "SENDGRID_API_KEY=${{ secrets.SENDGRID_API_KEY }}" > .env
          echo "SENDGRID_FROM_EMAIL=${{ secrets.SENDGRID_FROM_EMAIL }}" > .env
          echo "SENDGRID_TEMPLATE_ID=${{ secrets.SENDGRID_TEMPLATE_ID }}" > .env
          echo "DEPLOY_REDIS_HOST=${{ secrets.DEPLOY_REDIS_HOST }}" > .env
          echo "DEPLOY_REDIS_PORT=${{ secrets.DEPLOY_REDIS_PORT }}" > .env
          echo "DEPLOY_REDIS_PASSWORD=${{ secrets.DEPLOY_REDIS_PASSWORD }}" > .env

      # 8.5 단계: .env, docker-compose.yml 파일 EC2로 복사
      - name: Copy files to EC2
        uses: appleboy/scp-action@master
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USERNAME }}
          key: ${{ secrets.EC2_SSH_KEY }}
          source: ".env,docker-compose.yml"
          target: "/home/ubuntu"

      # 9단계: EC2 서버에 배포
      - name: Deploy to EC2
        # SSH를 통해 EC2에 접속해서 명령어를 실행하는 액션을 사용함.
        uses: appleboy/ssh-action@master
        with:
          # 접속할 EC2 서버의 IP 주소. Secrets에서 값을 가져옴.
          host: ${{ secrets.EC2_HOST }}
          # EC2 서버의 사용자 이름 (지금은 ubuntu). Secrets에서 값을 가져옴.
          username: ${{ secrets.EC2_USERNAME }}
          # EC2 접속에 필요한 .pem 키. Secrets에서 값을 가져옴.
          key: ${{ secrets.EC2_SSH_KEY }}
          # EC2 서버에 접속해서 아래 스크립트를 순서대로 실행시킬 거임.
          script: |
            # EC2 서버에서도 Docker Hub에 로그인해야 이미지를 받을 수 있음.
            docker login -u ${{ secrets.DOCKERHUB_USERNAME }} -p ${{ secrets.DOCKERHUB_TOKEN }}
            # Docker Hub에서 방금 올린 최신 버전의 이미지를 내려받음.
            docker pull ${{ secrets.DOCKERHUB_USERNAME }}/my-spring-app:latest
            # 기존에 실행 중이던 'my-app' 컨테이너가 있으면 중지시킴. 없으면 그냥 넘어감.
            docker stop my-app || true
            # 기존 'my-app' 컨테이너가 있으면 삭제함. 없으면 그냥 넘어감.
            docker rm my-app || true
            # 실행중인 컨테이너, 네트워크, 볼륨 등을 정리하고 종료
            docker compose down
            # docker-compose.yml, .env 파일이 ec2 내부에 있기 때문에 run 이 아닌 이 명령어로 실행
            # -d 백그라운드 실행
            docker compose up -d